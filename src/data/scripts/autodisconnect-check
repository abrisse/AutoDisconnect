#!/bin/sh

#
# App : AutoDisconnect
# Url : https://garage.maemo.org/projects/autodisconnect/
# Version: 0.2.2
# Author: Aymeric Brisse <aymeric.brisse@gmail.com>
# License: GNU General Public License
#

# ---------------------------------------------------------------------------
# FUNCTIONS
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
readparameters()
# ---------------------------------------------------------------------------
{
    # How often to test for inactivity (min)
    g_samplerate="`gconftool-2 -g /apps/autodisconnect/param_interval`"

    # Enable logging
    g_logging="true"

    # Notifications
    g_notifications="`gconftool-2 -g /apps/autodisconnect/param_notifications`"

    # Number of bytes allowed to be received without disconnect
    g_dontcountbytespermin=`gconftool-2 -g /apps/autodisconnect/param_min_bytes`

    # Interfaces to check
    g_enable=
    [[ `gconftool-2 -g /apps/autodisconnect/param_connection_wlan` = true ]] && g_enable="wlan "$g_enable
    [[ `gconftool-2 -g /apps/autodisconnect/param_connection_gprs` = true ]] && g_enable="gprs "$g_enable

    # Where to store the logfile. This is cleared when it goes over 100k.
    logfile=/var/log/autodisconnect.log

    # Number of bytes to ignore for each time period
    g_dontcountbytes=$((g_dontcountbytespermin*g_samplerate))

    # Convert min interval to sec interval
    g_samplerate=$((g_samplerate*60))
}

# ---------------------------------------------------------------------------
init()
# ---------------------------------------------------------------------------
{
    # Log monitor startup to file
    logentry "[Start]"

    # Kill every instances already running

    TmpFile=/tmp/$(basename $0).tmp

    `ps | egrep 'S[ ]*/bin/sh[ ]*/opt/autodisconnect/autodisconnect-check' | sed 's/^[ ]*\([0-9]*\) .*$/\1/g' > $TmpFile`

    while read Pid
    do
        [[ -n "$Pid" -a "$Pid" -ne "$$" ]] && {
            logentry "[Kill $Pid]"
            kill -KILL $Pid
        }
    done < $TmpFile

    # Allow dbus to work
    [[ -e /tmp/dbus-info ]] && eval `cat /tmp/dbus-info`

    export DBUS_SESSION_BUS_ADDRESS \
           DBUS_SESSION_BUS_PID \
           DBUS_SESSION_BUS_WINDOWID

    # Don't let log file get too big
    if [[ -w "$logfile" ]]; then
        size=`stat $logfile | grep Size | awk '{ print $2; }'`
        [[ "$size" -gt 50000 ]] && :>$logfile
    fi

    # Waiting for possible closing connections
    # Waiting for initial traffic to be made -> then the next check will close the connection
    sleep 30
}

# ---------------------------------------------------------------------------
logentry()
# ---------------------------------------------------------------------------
# Send a string to this function to append it to the log file
#
# Arg 1 - The text to log
{
    [[ "$g_logging" == "true" ]] && {
        echo -e "[`date`] [$$] $1" >> $logfile
    }
}

# ---------------------------------------------------------------------------
osnotify()
# ---------------------------------------------------------------------------
# Send a string to this function to generate a system popup
#
# Arg 1 - The text to display
{
    [[ "$g_notifications" == "true" ]] && {
		/usr/bin/dbus-send --type=method_call \
			--dest=org.freedesktop.Notifications \
			/org/freedesktop/Notifications \
			org.freedesktop.Notifications.SystemNoteInfoprint \
			string:"$1"
	}
}

# ---------------------------------------------------------------------------
disconnect()
# ---------------------------------------------------------------------------
# Disconnect current connection
#
# No args
{
    dbus-send --system --dest=com.nokia.icd \
        /com/nokia/icd_ui \
        com.nokia.icd_ui.disconnect \
        boolean:true
}

# ---------------------------------------------------------------------------
disable_quit()
# ---------------------------------------------------------------------------
# Disable for some interfaces
#
{
    short_interface=`echo "$interface" | tr -d 0-9`
    connection_check=`echo "$g_enable" | grep "$short_interface" 2>/dev/null`
    
	if [ -n "$short_interface" -a -n "$connection_check" ]; then
		osnotify "Auto-disconnect enabled for $short_interface"
		logentry "Auto-disconnect enabled for $short_interface"
	else
		logentry "Auto-disconnect disabled for ${short_interface:-other connections}"
        logentry "[Stop]"
		exit 0
	fi
}

# ---------------------------------------------------------------------------
main()
# ---------------------------------------------------------------------------
# Main entry point
#
{
    # Read parameters
    readparameters

    # Init -> Kill other instances & dbus & log & sleep
    init

    # Get interface
    	
	interface=$IFACE
	
	if [ -z "$interface" ]; then
		# gprs0 generally
		interface=`grep gprs0 /proc/net/route | tail -1 | cut -f1`
	fi

    # Quit if this interface doesn't have to be checked
    disable_quit
	
	packets_before=`grep $interface /proc/net/dev | awk -F":" '{print $2}' | awk '{print $1}'`
	
	#PERFORM MAIN MONITORING LOOPS
	while true
	do
		sleep $g_samplerate

        # Check if connection is still alive

        interface_check=`grep $interface /proc/net/route | tail -1 | cut -f1`

        [[ -z "$interface_check" ]] && {
            logentry "Connection $interface has been closed externally"
            break
        }

		packets_after=`grep $interface /proc/net/dev | awk -F":" '{print $2}' | awk '{print $1}'`

		if [ "$packets_after" -lt "$((packets_before+g_dontcountbytes))" ]; then
			disconnect
			osnotify "Connection $interface closed due to inactivity"
			logentry "Connection $interface has been closed by AutoDisconnect. Bytes received : $((packets_after-packets_before))"
			break
		else			
			logentry "$interface: Bytes received : $((packets_after-packets_before))"
			packets_before=$packets_after   
		fi

	done
	
}

# ---------------------------------------------------------------------------
# RUNTIME
# ---------------------------------------------------------------------------

# Start AutoDisconnect if enabled
[[ `gconftool-2 -g /apps/autodisconnect/param_enabled` = true ]] && main

logentry "[Stop]"

exit 0

